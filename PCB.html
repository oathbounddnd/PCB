<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PCB Investigation Kit</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; user-select:none; }
    body {
      background:
        radial-gradient(circle at 30% 20%, rgba(64, 64, 64, 0.3), transparent 50%),
        radial-gradient(circle at 70% 80%, rgba(96, 96, 96, 0.2), transparent 50%),
        linear-gradient(135deg, #2a2a2a, #1a1a1a);
      font-family:'Times New Roman', serif;
      color:#c0c0c0;
      height:100vh;
      overflow:hidden;
      position:relative;
    }
    .static-overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:
        radial-gradient(circle at 20% 30%, rgba(128, 128, 128, 0.06) 1px, transparent 1px),
        radial-gradient(circle at 80% 70%, rgba(160, 160, 160, 0.04) 1px, transparent 1px);
      background-size:6px 6px, 8px 8px;
      animation: staticNoise 0.2s infinite;
      pointer-events:none;
      z-index:1;
    }
    @keyframes staticNoise { 0%{opacity:.5;} 50%{opacity:.8;} 100%{opacity:.5;} }
    @keyframes shake {
      0% { transform: translate(0); }
      25% { transform: translate(-2px, 2px); }
      50% { transform: translate(2px, -2px); }
      75% { transform: translate(-2px, -2px); }
      100% { transform: translate(0); }
    }

    .screen { position:relative; z-index:2; height:100vh; padding:20px; display:none; overflow-y:auto; }
    .screen.active { display:flex; flex-direction:column; }

    .centered { justify-content:center; align-items:center; text-align:center; }

    .btn {
      padding: 12px 24px;
      background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
      border: 2px solid #888;
      color: #c0c0c0;
      border-radius: 8px;
      font-weight:bold;
      cursor:pointer;
      margin-top:12px;
    }
    .btn:active { transform:translateY(1px); }

    .pcb-logo {
      font-size: 28px;
      font-weight: bold;
      color: #a0a0a0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7), 0 0 15px #888888;
      margin-bottom: 10px;
      letter-spacing: 3px;
    }
    .home-subtitle {
      font-size: 16px;
      color: #888;
      margin-bottom: 40px;
      font-style: italic;
    }
    .game-code-input {
      width:200px; height:60px; font-size:28px; text-align:center;
      background:#1a1a1a; border:3px solid #666; border-radius:8px;
      color:#c0c0c0; letter-spacing:8px; margin-bottom:30px;
    }

    /* Room Selection */
    .room-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      max-width: 600px;
      margin: 20px auto;
    }
    .room-item {
      padding: 15px;
      background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
      border: 2px solid #555;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      transition: all 0.3s;
    }
    .room-item.selected {
      border-color: #90EE90;
      background: linear-gradient(145deg, #3a4a3a, #2a3a2a);
    }
    .room-item:hover {
      border-color: #888;
    }

    /* Navigation */
    .room-nav {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(42,42,42,0.9);
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #666;
      flex-wrap: wrap;
      max-width: 90vw;
      justify-content: center;
    }
    .nav-btn {
      padding: 8px 12px;
      background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
      border: 1px solid #666;
      color: #c0c0c0;
      border-radius: 5px;
      cursor: pointer;
      font-size: 10px;
      min-width: 60px;
      transition: all 0.3s;
    }
    .nav-btn:active { transform: translateY(1px); }
    
    /* Travel Indicator */
    .travel-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(42,42,42,0.95);
      border: 2px solid #666;
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      z-index: 1000;
      min-width: 200px;
    }
    .travel-progress {
      width: 100%;
      height: 8px;
      background: #2a2a2a;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 10px;
    }
    .travel-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #90EE90, #66cc66);
      width: 0%;
      transition: width 0.1s ease;
    }

    .tool-screen { align-items:center; }
    .header { text-align:center; margin-bottom:30px; width:100%; }
    .timer-display { font-size:32px; color:#90EE90; text-shadow:0 0 10px #90EE90; margin-bottom:20px; }
    .case-info { color:#888; margin-bottom:20px; }
    .current-room { 
      font-size: 18px; 
      color: #90EE90; 
      margin-bottom: 20px;
      text-shadow: 0 0 5px #90EE90;
    }
    
    /* Persistent Timer Overlay */
    .timer-overlay {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      background: rgba(42,42,42,0.9);
      border: 2px solid #90EE90;
      border-radius: 8px;
      padding: 10px 15px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      color: #90EE90;
      text-shadow: 0 0 10px #90EE90;
      box-shadow: 0 0 20px rgba(144,238,144,0.3);
      min-width: 120px;
      text-align: center;
      display: none;
    }
    .timer-overlay.active {
      display: block;
    }

    /* Spirit Cam Styles */
    .spiritcam-container {
      padding: 20px 20px 100px 20px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .camera-viewport {
      flex: 1;
      position: relative;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      margin: 20px 0;
      min-height: 400px;
    }
    .camera-feed {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    .camera-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      border-radius: 12px;
    }
    .overlay-spirit {
      background: radial-gradient(ellipse at center, 
        rgba(75, 0, 130, 0.1) 0%, 
        rgba(75, 0, 130, 0.3) 70%, 
        rgba(75, 0, 130, 0.6) 100%);
    }
    .overlay-nightvision {
      background: radial-gradient(ellipse at center,
        rgba(0, 255, 0, 0.1) 0%,
        rgba(0, 100, 0, 0.3) 70%,
        rgba(0, 50, 0, 0.8) 100%);
      filter: contrast(1.5) brightness(1.2);
    }
    .overlay-uv {
      background: linear-gradient(45deg, 
        rgba(138, 43, 226, 0.4), 
        rgba(75, 0, 130, 0.4));
      filter: hue-rotate(240deg) saturate(2);
    }
    .cam-controls {
      display: flex;
      justify-content: space-around;
      gap: 10px;
      margin-top: 15px;
    }
    .cam-btn {
      padding: 10px 15px;
      background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
      border: 2px solid #666;
      color: #c0c0c0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
      flex: 1;
      max-width: 80px;
    }
    .cam-btn.active {
      border-color: #90EE90;
      background: linear-gradient(145deg, #4a5a4a, #3a4a3a);
      color: #90EE90;
      box-shadow: 0 0 10px rgba(144,238,144,0.3);
    }
    .cam-status {
      text-align: center;
      margin-bottom: 15px;
      font-size: 14px;
      color: #888;
    }
    
    /* Ghost Orbs */
    .ghost-orb {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, 
        rgba(255, 255, 255, 0.9), 
        rgba(144, 238, 144, 0.6), 
        rgba(144, 238, 144, 0.1));
      filter: blur(1px);
      pointer-events: none;
      animation: float 10s infinite linear;
      box-shadow: 0 0 20px rgba(144, 238, 144, 0.5);
    }
    .ghost-orb.spirit-mode {
      filter: blur(0.5px) brightness(1.5);
      box-shadow: 0 0 30px rgba(144, 238, 144, 0.8);
    }
    @keyframes float {
      from {
        transform: translate(0, 100vh) scale(1);
      }
      to {
        transform: translate(var(--random-x), -100px) scale(1.2);
      }
    }
    .tools-grid { display:grid; grid-template-columns:1fr 1fr; gap:20px; width:100%; max-width:400px; }
    .tool-btn {
      padding:30px 20px; background:linear-gradient(145deg, #383838, #2a2a2a);
      border:2px solid #666; border-radius:12px; text-align:center; cursor:pointer;
    }
    .tool-btn.disabled { opacity:.4; cursor:not-allowed; }
    .tool-icon { font-size:24px; margin-bottom:10px; }
    .tool-name { font-size:16px; font-weight:bold; }

    .emf-container { padding:20px 20px 100px 20px; height:100vh; display:flex; flex-direction:column; position:relative; }
    .back-btn {
      position:absolute; top:20px; left:20px;
      padding:6px 10px; font-size:12px;
      background:linear-gradient(145deg, #3a3a3a, #2a2a2a);
      border:1px solid #666; border-radius:4px; cursor:pointer;
    }
    .status-bar {
      display:flex; justify-content:space-between; align-items:center;
      background:linear-gradient(135deg, rgba(42,42,42,.9), rgba(26,26,26,.9));
      border:2px solid #606060; padding:12px 18px; margin-bottom:20px; border-radius:8px;
    }
    .status-led { 
      width:12px; height:12px; border-radius:50%; margin-right:8px; 
      transition: all 0.3s ease;
      border: 2px solid rgba(255,255,255,0.3);
    }
    .status-led.red { 
      background: radial-gradient(circle, #ff4444, #8b0000);
      box-shadow: 0 0 0px rgba(255,68,68,0);
    }
    .status-led.red.on { 
      background: radial-gradient(circle, #ff6666, #ff4444);
      box-shadow: 0 0 15px rgba(255,68,68,0.8), 0 0 25px rgba(255,68,68,0.4);
      border-color: #ff6666;
    }
    .status-led.green { 
      background: radial-gradient(circle, #44ff44, #228b22);
      box-shadow: 0 0 15px rgba(68,255,68,0.8), 0 0 25px rgba(68,255,68,0.4);
      border-color: #66ff66;
    }
    .power-button { cursor:pointer; padding:6px 10px; border:1px solid #888; border-radius:4px; }
    .main-display { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; }
    .emf-meter {
      width:800px; height:400px; position:relative; margin-bottom:30px;
      background-image: url('./Dial.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      box-shadow: 
        inset 0 0 30px rgba(0,0,0,0.5),
        0 0 20px rgba(0,0,0,0.3);
    }
    .spike-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #ff4444, #8b0000);
      border-radius: 50%;
      border: 2px solid #aa2222;
      opacity: 0;
      transition: opacity 0.1s ease;
      box-shadow: 0 0 10px rgba(255,68,68,0.5);
    }
    .spike-indicator.flash {
      opacity: 1;
      animation: spikeFlash 0.3s ease-in-out;
    }
    .spike-indicator.sustained {
      opacity: 1;
      animation: sustainedSpike 1s ease-in-out infinite;
    }
    @keyframes spikeFlash {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.3); }
      100% { opacity: 1; transform: scale(1); }
    }
    @keyframes sustainedSpike {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    .meter-face { 
      position:absolute; top:0; left:0; 
      width:100%; height:100%;
    }
    .needle {
      position:absolute; top:50%; left:50%; width:4px; height:120px;
      background: linear-gradient(to top, #ff6666, #ffaaaa);
      transform-origin:bottom center;
      transform:translate(-50%, -50%) rotate(-90deg);
      transition:transform .4s ease-out;
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(255,102,102,0.6);
      z-index: 10;
    }
    .needle-center { 
      position:absolute; top:50%; left:50%; width:12px; height:12px; 
      background: radial-gradient(circle, #f0f0f0, #c0c0c0); 
      border-radius:50%; transform:translate(-50%, -50%);
      border: 2px solid #888;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      z-index: 15;
    }
    .digital-reading {
      background: linear-gradient(135deg, rgba(42,42,42,.9), rgba(26,26,26,.9));
      border:3px solid #606060; border-radius:12px; padding:20px; text-align:center;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }
    .emf-value { 
      font-size:52px; 
      font-family: 'Courier New', monospace;
      color: #90EE90;
      text-shadow: 0 0 10px rgba(144,238,144,0.8);
      letter-spacing: 2px;
    }
    .emf-unit {
      font-size: 12px;
      color: #888;
      margin-top: 8px;
      font-style: italic;
    }

    .ghost-status {
      position:fixed; top:20px; right:20px;
      background:rgba(42,42,42,0.9); border:1px solid #666; border-radius:5px;
      padding:10px; font-size:12px; color:#888; max-width:240px; z-index:10;
    }

    .scenario-info {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(42,42,42,0.9);
      border: 1px solid #666;
      border-radius: 5px;
      padding: 10px;
      font-size: 11px;
      color: #888;
      max-width: 200px;
      z-index: 10;
    }
    
    /* GPS Calibrating Message */
    .gps-message {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(42,42,42,0.95);
      border: 1px solid #90EE90;
      border-radius: 5px;
      padding: 8px 15px;
      font-size: 12px;
      color: #90EE90;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .gps-message.show { opacity: 1; }
    
    /* Setup Screens */
    .setup-screen {
      background: 
        radial-gradient(circle at 30% 20%, rgba(64, 64, 64, 0.3), transparent 50%),
        radial-gradient(circle at 70% 80%, rgba(96, 96, 96, 0.2), transparent 50%),
        linear-gradient(135deg, #2a2a2a, #1a1a1a);
      color: #c0c0c0;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    .calibration-text {
      font-size: 16px;
      margin-bottom: 30px;
      line-height: 1.6;
      max-width: 400px;
      color: #c0c0c0;
    }
    .loading-bar {
      width: 300px;
      height: 8px;
      background: #333;
      border: 1px solid #666;
      border-radius: 4px;
      overflow: hidden;
      margin: 20px auto;
    }
    .loading-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #90EE90, #66cc66);
      width: 0%;
      transition: width 0.1s ease;
      box-shadow: 0 0 10px rgba(144,238,144,0.5);
    }

    /* EMF Calibration Controls (Hidden by default, can be enabled for testing) */
    .emf-calibration {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(42,42,42,0.95);
      border: 1px solid #666;
      border-radius: 5px;
      padding: 8px;
      font-size: 10px;
      color: #888;
      z-index: 1000;
      display: none; /* Enable for testing: change to 'block' */
    }
    .emf-calibration input {
      width: 50px;
      font-size: 10px;
      margin: 2px;
    }
  </style>
</head>
<body>
  <div class="static-overlay"></div>

  <!-- Persistent Timer Overlay -->
  <div id="timerOverlay" class="timer-overlay">
    <div id="overlayTimer">00:00:00</div>
  </div>

  <!-- 0) INITIAL CALIBRATION -->
  <div id="calibrationScreen" class="screen setup-screen active">
    <div class="pcb-logo" style="margin-bottom: 20px;">PARANORMAL CONTAINMENT BUREAU</div>
    <div style="font-size: 14px; color: #888; margin-bottom: 40px; font-style: italic;">Investigation Kit v2.1 - Location Calibration Protocol</div>
    
    <div class="calibration-text">
      <strong style="color: #a0a0a0;">LOCATION SCANNING INITIALIZATION</strong><br><br>
      Stand at primary entry point facing interior.<br>
      Hold device steady and initiate calibration sequence.
    </div>
    <button class="btn" onclick="startHouseCalibration()">Initialize Location Scan</button>
    <div class="loading-bar" id="calibrationLoader" style="display:none;">
      <div class="loading-bar-fill" id="calibrationProgress"></div>
    </div>
    <div id="calibrationStatus" style="margin-top:15px; color:#90EE90; font-size:12px;"></div>
  </div>

  <!-- 1) ROOM SELECTION -->
  <div id="roomScreen" class="screen">
    <div class="pcb-logo" style="margin-bottom: 10px;">PARANORMAL CONTAINMENT BUREAU</div>
    <div style="font-size: 14px; color: #888; margin-bottom: 30px; font-style: italic;">Location Mapping - Room Configuration</div>
    
    <div style="text-align:center; margin-bottom:30px;">
      <h2 style="color: #a0a0a0; font-size: 20px;">LOCATION STRUCTURE DETECTED</h2>
      <p style="color:#888; margin-top:10px; font-size: 14px;">Confirm accessible areas for investigation perimeter</p>
    </div>
    <div class="room-grid" id="roomGrid">
      <!-- Rooms will be populated by JavaScript -->
    </div>
    <div style="text-align:center; margin-top:30px;">
      <button class="btn" onclick="finishRoomSelection()">Confirm Location Parameters</button>
    </div>
  </div>

  <!-- 2) HOME -->
  <div id="homeScreen" class="screen centered">
    <div class="pcb-logo">PARANORMAL CONTAINMENT BUREAU</div>
    <div class="home-subtitle">Investigation Kit v2.1</div>
    <input type="text" class="game-code-input" id="gameCodeInput" maxlength="3" placeholder="---">
    <div style="margin-bottom: 20px; color: #888; font-size: 14px;">Enter Case Code (Emailed to Lead Investigator)</div>
    <button class="btn" onclick="startInvestigation()">Start Investigation</button>
    <div id="codeError" style="margin-top: 20px; color: #ff6666; font-size: 14px; display: none;">
      ‚ùå Error: Wrong Case Code
    </div>
    <div style="margin-top: 40px; font-size: 12px; color: #666;">
      All players: same rooms, same code.
    </div>
  </div>

  <!-- GPS Calibrating Message -->
  <div class="gps-message" id="gpsMessage">
    üì° Location sensors calibrating... Mapping area parameters
  </div>

  <!-- 3) TOOL SELECTION -->
  <div id="toolScreen" class="screen tool-screen">
    <div class="header">
      <h1>PCB Investigation Kit</h1>
      <div class="timer-display" id="timerDisplay">00:00:00</div>
      <div class="current-room">Current Room: <span id="currentRoomDisplay">Living Room</span></div>
    </div>
    <div class="tools-grid">
      <div class="tool-btn" onclick="openTool('emf')">
        <div class="tool-icon">üìä</div>
        <div class="tool-name">EMF READER</div>
      </div>
      <div class="tool-btn disabled">
        <div class="tool-icon">üìª</div>
        <div class="tool-name">SPIRIT BOX</div>
      </div>
      <div class="tool-btn disabled">
        <div class="tool-icon">üé§</div>
        <div class="tool-name">EVP RECORDER</div>
      </div>
      <div class="tool-btn" onclick="openTool('spiritcam')">
        <div class="tool-icon">üì±</div>
        <div class="tool-name">SPIRIT CAM</div>
      </div>
    </div>
    <button class="btn" onclick="endInvestigation()" style="margin-top: 40px; background: linear-gradient(145deg, #4a2a2a, #2a1a1a); border-color: #664444;">
      End Investigation
    </button>
  </div>

  <!-- 4) EMF -->
  <div id="emfScreen" class="screen">
    <div class="emf-container">
      <button class="back-btn" onclick="backToTools()">‚Üê TOOLS</button>
      <div class="emf-header" style="text-align:center; margin-bottom:15px;">
        <div style="font-size:22px; font-weight:bold; color:#a0a0a0;">ELECTROMAGNETIC FIELD DETECTOR</div>
        <div style="font-size:11px; color:#707070; font-style:italic;">Patent No. 1887-EMF-UK | Est. Her Majesty's Service</div>
      </div>
      <div class="status-bar">
        <div style="display:flex; align-items:center;">
          <div class="status-led red" id="powerLed"></div>
          <span class="power-button" id="powerBtn" onclick="togglePower()">POWER</span>
        </div>
        <div style="display:flex; align-items:center;">
          <div class="status-led green" id="calibLed"></div>
          <span>CALIBRATED</span>
        </div>
        <div style="display:flex; align-items:center;">
          <div class="status-led red" id="anomalyLed"></div>
          <span>ANOMALY</span>
        </div>
      </div>
      <div class="main-display">
        <div class="emf-meter">
          <div class="spike-indicator" id="spikeIndicator"></div>
          <div class="meter-face">
            <div class="needle"></div>
            <div class="needle-center"></div>
          </div>
        </div>
        <div class="digital-reading">
          <div class="emf-value">0.00</div>
          <div class="emf-unit">EMF Level (0-6 Scale)</div>
        </div>
      </div>
    </div>
    
    <!-- Room Navigation -->
    <div class="room-nav" id="roomNavigation">
      <!-- Navigation buttons will be populated by JavaScript -->
    </div>
  </div>

  <!-- SPIRIT CAM SCREEN -->
  <div id="spiritcamScreen" class="screen">
    <div class="spiritcam-container">
      <button class="back-btn" onclick="backToTools()">‚Üê TOOLS</button>
      
      <div class="emf-header" style="text-align:center; margin-bottom:15px;">
        <div style="font-size:22px; font-weight:bold; color:#a0a0a0;">SPIRIT CAMERA INTERFACE</div>
        <div style="font-size:11px; color:#707070; font-style:italic;">Paranormal Detection System | Est. Her Majesty's Service</div>
      </div>

      <div class="cam-status" id="camStatus">
        Initializing camera feed...
      </div>

      <div class="camera-viewport">
        <video id="cameraFeed" class="camera-feed" autoplay muted playsinline></video>
        <div id="cameraOverlay" class="camera-overlay"></div>
      </div>

      <div class="cam-controls">
        <div class="cam-btn active" onclick="setCameraMode('normal')" id="btnNormal">NORMAL</div>
        <div class="cam-btn" onclick="setCameraMode('nightvision')" id="btnNightVision">NIGHT</div>
        <div class="cam-btn" onclick="setCameraMode('spirit')" id="btnSpirit">SPIRIT</div>
        <div class="cam-btn" onclick="setCameraMode('uv')" id="btnUV">UV</div>
      </div>
    </div>
    
    <!-- Room Navigation -->
    <div class="room-nav" id="roomNavigationCam">
      <!-- Navigation buttons will be populated by JavaScript -->
    </div>
  </div>

  <!-- EMF Calibration Controls (for testing - hidden by default) -->
  <div class="emf-calibration" id="emfCalibration">
    <div>EMF Dial Calibration</div>
    <div>Min Angle: <input type="number" id="angleMin" value="-90" onchange="updateDialCalibration()"></div>
    <div>Max Angle: <input type="number" id="angleMax" value="30" onchange="updateDialCalibration()"></div>
    <div>Test EMF: <input type="range" min="0" max="6" step="0.1" value="0" id="testEMF" oninput="testEMFReading()"></div>
  </div>

  <!-- DEBUG -->
  <div class="ghost-status" style="display:none;">
    <div><strong>DEBUG:</strong></div>
    <div>Rooms: <span id="dbgRoomCount">0</span></div>
    <div>Current: <span id="dbgCurrentRoom">--</span></div>
    <div>Ghost: <span id="dbgGhostRoom">--</span></div>
    <div>In Zone: <span id="dbgInZone">NO</span></div>
  </div>

  <!-- Scenario Info -->
  <div class="scenario-info" id="scenarioInfo" style="display:none;">
    <div><strong>Case File:</strong></div>
    <div>Type: <span id="ghostType">--</span></div>
    <div>Class: <span id="ghostClass">--</span></div>
    <div>Room: <span id="ghostRoomInfo">--</span></div>
    <div>Activity: <span id="activityLevel">--</span></div>
  </div>

  <script>
    // ===== GLOBAL STATE =====
    let currentScreen = 'calibrationScreen';

    // Available rooms
    const ALL_ROOMS = [
      'Porch', 'Living Room', 'Garage', 'Kitchen', 'Stairs', 'Hallway', 
      'Upstairs Landing', 'Bathroom 1', 'Bathroom 2', 'Bedroom 1', 
      'Bedroom 2', 'Bedroom 3', 'Bedroom 4', 'Dinning Room', 'Conservatory'
    ];

    // Game state
    let availableRooms = [];
    let currentRoom = 'Living Room';
    let gameCode = '';
    let currentScenario = null;
    let investigationActive = false;
    let startTime = null;
    let timerInterval = null;

    // EMF - Enhanced with calibration
    let devicePowered = false;
    let emfAnimationInterval = null;
    let currentEMF = 0.0;
    let emfAngleMin = -90;  // Adjustable dial calibration
    let emfAngleMax = 30;   // Adjustable dial calibration
    
    // EMF Audio/Visual effects
    let audioContext = null;
    let beepInterval = null;
    let lastEMFValue = 0;
    let spikeDetected = false;
    let spikeFlashInterval = null;
    
    // Travel System
    let isTraveling = false;
    let travelStartTime = 0;
    let travelDuration = 3000; // 3 seconds
    let travelDestination = '';
    let lastShakeTime = 0;
    
    // Room Detection System
    let roomEnterTime = 0;
    let roomReadyForReadings = false;
    let gpsCalibrating = false;
    let roomTimerInterval = null;
    let evidenceTimer = null;
    let evidenceActive = false;

    // Ghost Activity System
    let ghostEventTimer = null;
    let ghostActivityActive = false;

    // ===== SPIRIT CAM SYSTEM =====
    let cameraStream = null;
    let cameraMode = 'normal';
    let flashlightOn = false;
    
    // ===== GHOST ORBS SYSTEM =====
    let ghostOrbsActive = false;
    let orbsVisibilityState = false; // true = visible, false = hidden
    let orbsLoop = null;
    let currentOrbs = [];
    let maxOrbs = 5;
    let orbVisibleDuration = 60000; // 1 minute
    let orbHiddenDuration = 120000; // 2 minutes

    // ===== GHOST DATA SYSTEM (JSON-based) =====
    let currentGhostData = null;
    let ghostTimeline = [];
    let timelinePosition = 0;
    let gameStartTime = 0;
    let ghostEventQueue = [];
    let eventProcessingInterval = null;

    // ===== FILE-BASED GHOST DATA SYSTEM =====
    let loadedGhostFiles = {}; // Store loaded files in memory

    // Scenarios data (embedded for local file usage - fallback)
    let scenariosData = {
      scenarios: {
        "100": {
          entity_type: "Spirit (T-S)",
          class: "Class II - Disruptive", 
          class_level: 2,
          supplementary: "S",
          room: "Living Room",
          description: "Residual human consciousness of former homeowner. Attached to familiar surroundings.",
          emf_base: 2.8,
          activity_level: "Medium",
          aggressiveness: 0.3,
          evidence: ["Ghost Orbs", "Spirit Box", "EMF Level 5"],
          has_emf: true,
          behavior: "Moves furniture, responds to questions, seeks acknowledgment",
          events: [],
          special_behaviors: {}
        }
      }
    };

    // JSON Scenario Loading System (Legacy - silent failure)
    async function loadScenarioJSON(code) {
      try {
        const response = await fetch(`./scenario_${code}.json`);
        if (!response.ok) {
          throw new Error(`Scenario ${code} not found`);
        }
        const scenarioData = await response.json();
        return scenarioData;
      } catch (error) {
        // Silent failure - user is using new ghost data format
        return null;
      }
    }
    
    // ===== NEW GHOST DATA LOADING SYSTEM =====
    async function loadGhostDataJSON(code) {
      try {
        // Load from Games/ folder: Games/104.json
        const response = await fetch(`./Games/${code}.json`);
        if (!response.ok) {
          throw new Error(`Ghost data Games/${code}.json not found`);
        }
        const ghostDataText = await response.text();
        
        // Process the file content to handle the custom syntax
        const processedContent = processGhostDataSyntax(ghostDataText);
        
        // Parse as JSON
        const ghostData = JSON.parse(processedContent);
        
        return ghostData;
      } catch (error) {
        // Silent failure - no user-visible errors
        return null;
      }
    }
    
    function processGhostDataSyntax(content) {
      // Remove comment lines
      content = content.replace(/\/\/ .+\n/g, '');
      
      // ACTUALLY PARSE the user's Sequence syntax dynamically
      if (content.includes('"timeline": new Sequence()')) {
        // Extract the entire timeline section
        const timelineMatch = content.match(/"timeline":\s*new Sequence\(\)([\s\S]*?)(?=,\s*"triggers")/);
        
        if (timelineMatch) {
          const sequenceContent = timelineMatch[1];
          const events = [];
          
          // Split by .effect( to find individual events
          const effectMatches = sequenceContent.split(/\.effect\(/);
          
          for (let i = 1; i < effectMatches.length; i++) {
            const eventBlock = '.effect(' + effectMatches[i];
            
            // Parse each property from the event block
            const event = {};
            
            // Extract effect type
            const effectMatch = eventBlock.match(/\.effect\("([^"]+)"\)/);
            if (effectMatch) event.effect = effectMatch[1];
            
            // Extract time (in minutes)
            const timeMatch = eventBlock.match(/\.time\(([\d.]+)\)/);
            if (timeMatch) event.time = parseFloat(timeMatch[1]);
            
            // Extract EMF spike value
            const emfMatch = eventBlock.match(/\.emf_spike\(([\d.]+)\)/);
            if (emfMatch) event.emf_spike = parseFloat(emfMatch[1]);
            
            // Extract duration
            const durationMatch = eventBlock.match(/\.duration\((\d+)\)/);
            if (durationMatch) event.duration = parseInt(durationMatch[1]);
            
            // Extract audio file
            const audioMatch = eventBlock.match(/\.audio\("([^"]+)"\)/);
            if (audioMatch) event.audio = audioMatch[1];
            
            // Extract volume if present
            const volumeMatch = eventBlock.match(/\.volume\("([^"]+)"\)/);
            if (volumeMatch) event.volume = volumeMatch[1];
            
            events.push(event);
          }
          
          // Replace the timeline section with parsed events
          content = content.replace(
            /"timeline":\s*new Sequence\(\)[\s\S]*?(?=,\s*"triggers")/,
            `"timeline": ${JSON.stringify(events)}`
          );
        }
      }
      
      // Handle triggers (same as before)
      content = content.replace(
        /new Sequence\(\)\.effect\("emf_spike"\)\.emf_spike\(5\.1\)\.duration\(2\)\.audio\("footsteps\.mp3"\)/g,
        JSON.stringify({ effect: "emf_spike", emf_spike: 5.1, duration: 2, audio: "footsteps.mp3" })
      );
      
      content = content.replace(
        /new Sequence\(\)\.effect\("emf_spike"\)\.emf_spike\(2\.8\)\.duration\(3\)\.audio\("door_creak\.mp3"\)/g,
        JSON.stringify({ effect: "emf_spike", emf_spike: 2.8, duration: 3, audio: "door_creak.mp3" })
      );
      
      content = content.replace(
        /new Sequence\(\)\.effect\("emf_spike"\)\.emf_spike\(4\.1\)\.duration\(3\)\.audio\("male_voice_angry\.mp3"\)/g,
        JSON.stringify({ effect: "emf_spike", emf_spike: 4.1, duration: 3, audio: "male_voice_angry.mp3" })
      );
      
      return content;
    }

    async function loadScenario(code) {
      // Try to load external JSON first
      let scenario = await loadScenarioJSON(code);
      
      // Fall back to embedded data if JSON fails
      if (!scenario && scenariosData.scenarios[code]) {
        scenario = scenariosData.scenarios[code];
        // Add missing fields for embedded scenarios
        scenario.events = scenario.events || [];
        scenario.special_behaviors = scenario.special_behaviors || {};
      }
      
      return scenario;
    }
    // ===== UI HELPERS =====
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      currentScreen = id;
    }

    function updateDebug() {
      document.getElementById('dbgRoomCount').textContent = availableRooms.length;
      document.getElementById('dbgCurrentRoom').textContent = currentRoom;
      document.getElementById('dbgGhostRoom').textContent = currentGhostData ? 
        currentGhostData.ghost_info.location : '--';
      document.getElementById('dbgInZone').textContent = 
        (currentGhostData && currentRoom.toLowerCase().replace(/\s+/g, '_') === currentGhostData.ghost_info.location) ? 'YES' : 'NO';
    }

    // ===== HOUSE CALIBRATION =====
    function startHouseCalibration() {
      document.getElementById('calibrationLoader').style.display = 'block';
      document.querySelector('.calibration-text').style.opacity = '0.5';
      document.querySelector('.btn').style.display = 'none';
      
      const progress = document.getElementById('calibrationProgress');
      const status = document.getElementById('calibrationStatus');
      
      let currentProgress = 0;
      const totalTime = 8000 + Math.random() * 4000; // 8-12 seconds
      const updateInterval = 100;
      
      status.textContent = 'Initializing electromagnetic field mapping...';
      
      const progressInterval = setInterval(() => {
        currentProgress += (updateInterval / totalTime) * 100;
        progress.style.width = Math.min(currentProgress, 100) + '%';
        
        if (currentProgress >= 25 && currentProgress < 50) {
          status.textContent = 'Scanning structural layout and dimensions...';
        } else if (currentProgress >= 50 && currentProgress < 75) {
          status.textContent = 'Calibrating paranormal detection sensors...';
        } else if (currentProgress >= 75 && currentProgress < 95) {
          status.textContent = 'Establishing baseline electromagnetic readings...';
        } else if (currentProgress >= 95) {
          status.textContent = 'Location parameters successfully configured.';
        }
        
        if (currentProgress >= 100) {
          clearInterval(progressInterval);
          setTimeout(() => {
            showScreen('roomScreen');
            populateRoomGrid();
          }, 1000);
        }
      }, updateInterval);
    }

    // ===== ROOM SELECTION =====
    function populateRoomGrid() {
      const grid = document.getElementById('roomGrid');
      grid.innerHTML = '';
      
      ALL_ROOMS.forEach(room => {
        const roomDiv = document.createElement('div');
        roomDiv.className = 'room-item';
        roomDiv.textContent = room;
        roomDiv.onclick = () => toggleRoom(room, roomDiv);
        grid.appendChild(roomDiv);
      });
    }

    function toggleRoom(room, element) {
      if (availableRooms.includes(room)) {
        availableRooms = availableRooms.filter(r => r !== room);
        element.classList.remove('selected');
      } else {
        availableRooms.push(room);
        element.classList.add('selected');
      }
      updateDebug();
    }

    function finishRoomSelection() {
      if (availableRooms.length < 1) {
        alert('Please select at least 1 room');
        return;
      }
      
      // Set default current room to first selected room (or Living Room if available)
      if (availableRooms.includes('Living Room')) {
        currentRoom = 'Living Room';
      } else {
        currentRoom = availableRooms[0];
      }
      
      showScreen('homeScreen');
      updateDebug();
    }

    // ===== ROOM NAVIGATION =====
    function createRoomNavigation(containerId = 'roomNavigation') {
      const nav = document.getElementById(containerId);
      if (!nav) return;
      
      nav.innerHTML = '';
      
      availableRooms.forEach(room => {
        const btn = document.createElement('div');
        btn.className = 'nav-btn';
        btn.textContent = room.length > 8 ? room.substring(0,7) + '...' : room;
        
        if (room === currentRoom) {
          btn.style.background = 'linear-gradient(145deg, #4a6a4a, #2a4a2a)';
          btn.style.borderColor = '#90EE90';
        } else if (isTraveling) {
          btn.classList.add('disabled');
        } else {
          btn.onclick = () => startTravel(room);
        }
        
        nav.appendChild(btn);
      });
    }

    function startTravel(room) {
      if (room === currentRoom) return;
      
      // Instant travel - no delays
      currentRoom = room;
      document.getElementById('currentRoomDisplay').textContent = currentRoom;
      
      // Start room timer (now instant)
      startRoomTimer();
      
      // Trigger ghost events for room entry
      triggerGhostEvent('player_enters_room');
      
      // Handle Spirit Cam ghost room detection
      if (currentScreen === 'spiritcamScreen') {
        const ghostRoom = currentGhostData?.ghost_info?.location;
        const playerInGhostRoom = (currentRoom.toLowerCase().replace(/\s+/g, '_') === ghostRoom);
        
        if (playerInGhostRoom) {
          // Entered ghost room - start orbs if not already active
          if (!ghostOrbsActive) {
            startGhostOrbs();
          }
        } else {
          // Left ghost room - stop orbs
          stopGhostOrbs();
        }
      }
      
      createRoomNavigation();
      updateDebug();
    }
    // ===== NEW JSON EVENT SYSTEM =====
    let currentGhostRoom = null; // Track where ghost currently is
    let timelineCheckInterval = null;
    
    function getCurrentGhostRoom() {
      // Return current ghost location (can change for mobile ghosts)
      return currentGhostRoom || (currentGhostData ? currentGhostData.ghost_info.location : null);
    }
    
    function startTimelineSystem() {
      // Handle new ghost data format
      if (currentGhostData && currentGhostData.timeline) {
        gameStartTime = Date.now();
        startGhostTimeline();
        return;
      }
    }
    
    // ===== NEW GHOST TIMELINE SYSTEM =====
    function startGhostTimeline() {
      if (!currentGhostData || !currentGhostData.timeline) return;
      
      // Timeline is now a processed array of events
      const timelineEvents = currentGhostData.timeline;
      
      if (!timelineEvents || !Array.isArray(timelineEvents)) {
        return;
      }
      
      // Schedule all timeline events
      timelineEvents.forEach((event, index) => {
        if (event.time !== undefined) {
          const delay = event.time * 60 * 1000; // Convert MINUTES to milliseconds
          setTimeout(() => {
            if (investigationActive) {
              executeGhostEvent(event);
            }
          }, delay);
        }
      });
      
      // Start continuous event checking
      if (eventProcessingInterval) clearInterval(eventProcessingInterval);
      eventProcessingInterval = setInterval(() => {
        processGhostEventQueue();
      }, 100); // Check every 100ms for smooth event processing
    }
    
    function executeGhostEvent(event) {
      // Silent execution - no debug messages
      
      // TOOL DETECTION PRINCIPLE:
      // - Ghost events always happen on schedule (timeline continues)
      // - But events are only DETECTABLE when correct equipment is powered on
      // - This applies to ALL tools: EMF Reader, Spirit Box, Thermometer, UV Light, etc.
      
      // Check if player is in ghost room (some events only trigger there)
      const ghostRoom = currentGhostData.ghost_info.location;
      const playerInGhostRoom = (currentRoom.toLowerCase().replace(/\s+/g, '_') === ghostRoom);
      
      // EMF Spike events - only detectable if EMF reader is powered on
      if (event.effect === 'emf_spike' && event.emf_spike) {
        if (devicePowered) {
          triggerEMFSpike(event.emf_spike, event.duration || 3);
        }
        // Event still happened, just not detectable without EMF reader
      }
      
      // Ghost Orbs events - only detectable if Spirit Cam is active
      if (event.effect === 'ghost_orbs') {
        if (currentScreen === 'spiritcamScreen') {
          triggerGhostOrbs(event);
        }
        // Event still happened, just not detectable without Spirit Cam
      }
      
      // Spirit Box events - only detectable if Spirit Box is powered on
      // if (event.effect === 'spirit_response' && event.audio) {
      //   if (spiritBoxPowered) {
      //     playGhostAudio(`./Games/Audio/${event.audio}`, event.volume || 'medium');
      //   }
      // }
      
      // Auto events (these work regardless of equipment - environmental)
      if (event.effect === 'door_slam') {
        triggerDoorSlam();
      } else if (event.effect === 'door_creak') {
        triggerDoorCreak();
      } else if (event.effect === 'lights_flicker') {
        triggerLightsFlicker();
      } else if (event.effect === 'screen_shake') {
        triggerScreenShake();
      }
      
      // Ghost movement
      if (event.ghost_moves_to) {
        currentGhostRoom = event.ghost_moves_to;
      }
      
      // Audio events - tool-specific detection
      if (event.audio) {
        const audioPath = `./Games/Audio/${event.audio}`;
        const volume = event.volume || 'medium';
        
        // Only play EMF-related audio if EMF reader is on
        if (event.effect === 'emf_spike' && devicePowered) {
          playGhostAudio(audioPath, volume);
        } else if (event.effect !== 'emf_spike') {
          // Non-EMF audio plays regardless (environmental sounds)
          playGhostAudio(audioPath, volume);
        }
      }
    }
    
    // ===== AUDIO PLAYBACK SYSTEM =====
    function playGhostAudio(audioPath, volume = 'medium') {
      try {
        const audio = new Audio(audioPath);
        
        // Set volume based on level
        switch(volume.toLowerCase()) {
          case 'quiet':
            audio.volume = 0.3;
            break;
          case 'medium':
            audio.volume = 0.6;
            break;
          case 'loud':
            audio.volume = 0.9;
            break;
          default:
            audio.volume = 0.6;
        }
        
        // Play the audio
        audio.play().catch(error => {
          // Silent failure - no visual indicators
        });
        
        // Clean up after audio ends
        audio.addEventListener('ended', () => {
          audio.src = '';
        });
        
      } catch (error) {
        // Silent failure - no visual indicators
      }
    }
    
    function processGhostEventQueue() {
      // Process any queued events (for future trigger system)
      while (ghostEventQueue.length > 0) {
        const event = ghostEventQueue.shift();
        executeGhostEvent(event);
      }
    }
    
    // ===== GHOST EVENT FUNCTIONS =====
    function triggerEMFSpike(value, duration = 3) {
      if (!devicePowered) return; // Only work if EMF reader is on
      
      // Store original EMF value
      const originalEMF = currentEMF;
      
      // Set EMF to spike value
      currentEMF = value;
      updateEMFDisplay(currentEMF);
      
      // Turn on anomaly LED
      document.getElementById('anomalyLed').classList.add('on');
      
      // Restore normal EMF after duration
      setTimeout(() => {
        currentEMF = originalEMF;
        updateEMFDisplay(currentEMF);
        document.getElementById('anomalyLed').classList.remove('on');
      }, duration * 1000);
    }
    
    function triggerDoorSlam() {
      // Auto plays sound + EMF 4.2 + shake
      triggerEMFSpike(4.2, 2);
      triggerScreenShake();
      playGhostAudio('./Games/Audio/door_slam.mp3', 'loud');
    }
    
    function triggerDoorCreak() {
      // Auto plays sound + EMF 2.8
      triggerEMFSpike(2.8, 3);
      playGhostAudio('./Games/Audio/door_creak.mp3', 'medium');
    }
    
    function triggerLightsFlicker() {
      // Auto flickers for 3 seconds
      const body = document.body;
      let flickerCount = 0;
      const flickerInterval = setInterval(() => {
        body.style.filter = flickerCount % 2 === 0 ? 'brightness(0.3)' : 'brightness(1)';
        flickerCount++;
        if (flickerCount >= 6) { // 3 seconds of flickering
          clearInterval(flickerInterval);
          body.style.filter = 'brightness(1)';
        }
      }, 500);
    }
    
    function triggerScreenShake() {
      const body = document.body;
      body.style.animation = 'shake 0.5s ease-in-out';
      setTimeout(() => {
        body.style.animation = '';
      }, 500);
    }
    
    function triggerGhostOrbs(event) {
      // Only trigger if Spirit Cam is active and player is in ghost room
      if (currentScreen !== 'spiritcamScreen') return;
      
      const ghostRoom = currentGhostData.ghost_info.location;
      const playerInGhostRoom = (currentRoom.toLowerCase().replace(/\s+/g, '_') === ghostRoom);
      
      if (!playerInGhostRoom) return;
      
      // Parse orb event parameters
      const visibleDuration = (event.visible_duration || 1) * 60 * 1000; // Convert minutes to ms
      const hiddenDuration = (event.hidden_duration || 2) * 60 * 1000;   // Convert minutes to ms
      const maxOrbCount = event.max_orbs || 5;
      
      // Update global orb settings
      orbVisibleDuration = visibleDuration;
      orbHiddenDuration = hiddenDuration;
      maxOrbs = maxOrbCount;
      
      // Start or restart ghost orbs system
      if (ghostOrbsActive) {
        stopGhostOrbs();
      }
      startGhostOrbs();
    }
    
    // ===== GHOST TRIGGER SYSTEM =====
    function triggerGhostEvent(triggerName) {
      if (!currentGhostData || !currentGhostData.triggers) return;
      
      const trigger = currentGhostData.triggers[triggerName];
      if (!trigger || !Array.isArray(trigger)) return;
      
      // Execute a random response from the trigger array
      const randomResponse = trigger[Math.floor(Math.random() * trigger.length)];
      if (randomResponse) {
        // Trigger response is now a processed object, not a Sequence
        executeGhostEvent(randomResponse);
      }
    }
    
    function checkTimelineEvents() {
      if (!investigationActive || !currentScenario) return;
      
      const currentMinutes = Math.floor((Date.now() - startTime) / 60000);
      const timelineKey = currentMinutes + '_minutes';
      
      if (currentScenario.TIMELINE_EVENTS[timelineKey]) {
        const event = currentScenario.TIMELINE_EVENTS[timelineKey];
        
        // Only execute if player is in ghost room
        if (currentRoom === getCurrentGhostRoom()) {
          executeTimelineEvent(event);
        }
      }
    }
    
    function executeTimelineEvent(event) {
      console.log(`Timeline Event: ${event.description}`);
      
      // Check if this is a ghost movement event
      if (event.ghost_moves_to) {
        currentGhostRoom = event.ghost_moves_to;
        console.log(`Ghost moved to: ${currentGhostRoom}`);
      }
      
      // Execute the event effects
      if (event.effects) {
        executeEvent(event.effects);
      }
    }
    
    function executeEvent(eventData) {
      if (!eventData.event) return;
      
      console.log(`Executing Event: ${eventData.event}`);
      
      switch(eventData.event) {
        case 'emf_spike_minor':
          spikeEMF(eventData.emf_spike || 5.1, (eventData.duration_seconds || 2) * 1000);
          if (eventData.audio) playAudioFile(eventData.audio);
          break;
          
        case 'emf_spike_major':
          spikeEMF(eventData.emf_spike || 5.8, (eventData.duration_seconds || 4) * 1000);
          if (eventData.audio) playAudioFile(eventData.audio);
          break;
          
        case 'play_audio':
          if (eventData.audio) playAudioFile(eventData.audio, eventData.volume);
          if (eventData.emf_spike) spikeEMF(eventData.emf_spike, 3000);
          break;
          
        case 'door_slam':
          playAudioFile('door_slam.mp3', 'loud');
          spikeEMF(4.2, 3000);
          triggerScreenShake();
          break;
          
        case 'door_creak':
          playAudioFile('door_creak.mp3', 'quiet');
          spikeEMF(2.8, 3000);
          break;
          
        case 'lights_flicker':
          triggerLightFlicker(eventData.duration_seconds || 3);
          spikeEMF(3.1, 2000);
          break;
      }
    }
    
    function spikeEMF(level, durationMs) {
      if (!devicePowered) return;
      
      const originalEMF = currentEMF;
      currentEMF = level;
      updateEMFDisplay(currentEMF);
      
      // Return to baseline after duration
      setTimeout(() => {
        currentEMF = originalEMF;
        updateEMFDisplay(currentEMF);
      }, durationMs);
    }
    
    function playAudioFile(filename, volume = 'medium') {
      // Placeholder for audio system
      console.log(`Playing audio: ${filename} at ${volume} volume`);
      // Will implement actual audio loading/playing later
    }
    
    function triggerScreenShake() {
      document.body.style.animation = 'shake 0.5s';
      setTimeout(() => {
        document.body.style.animation = '';
      }, 500);
    }
    
    function triggerLightFlicker(durationSeconds) {
      // Placeholder for light flicker effect
      console.log(`Lights flicker for ${durationSeconds} seconds`);
    }
    
    function showGPSMessage() {
      const gpsMsg = document.getElementById('gpsMessage');
      gpsMsg.classList.add('show');
      
      setTimeout(() => {
        gpsMsg.classList.remove('show');
      }, 3000);
    }

// --- Player movement / room entry handler ---
function onPlayerEntersRoom(roomName) {
  currentRoom = roomName;
  console.log(`Player entered room: ${roomName}`);

  // Notify ghost trigger system
  triggerGhostEvent('player_enters_room', { room: roomName });

  // Optional: update Spirit Cam text
  const camLabel = document.getElementById('spiritCamRoom');
  if (camLabel) camLabel.textContent = roomName;

  // If we're in the ghost's room and on Spirit Cam, enable orbs
  if (ghost_info && roomName === ghost_info.location) {
    console.log('Entered ghost room ‚Üí triggering ghost room effects.');
  }
}

// --- Player movement / room entry handler (safe) ---
function onPlayerEntersRoom(roomName) {
  // if no room was passed in, just use whatever the game thinks is current
  if (!roomName) {
    roomName = currentRoom;
  }

  // update global
  currentRoom = roomName;

  console.log(`Player entered room: ${roomName}`);

  // fire JSON triggers like "player_enters_room"
  // your triggerGhostEvent(...) already exists above
  triggerGhostEvent('player_enters_room');

  // check if this is the ghost's room (use currentGhostData, not ghost_info)
  const ghostRoom = currentGhostData?.ghost_info?.location;
  if (ghostRoom) {
    // normalise: "Dining Room" -> "dining_room"
    const normalisedPlayerRoom = roomName.toLowerCase().replace(/\s+/g, '_');
    if (normalisedPlayerRoom === ghostRoom) {
      // we're in the ghost room ‚Äì this is where Spirit Cam orbs are allowed
      // we don't have to do anything here because the orb event itself starts them
      // but this block is now SAFE (no ReferenceError)
      // console.log('Player entered the ghost room.');
    }
  }
}

    
function startRoomTimer() {
  // No delays - room is immediately ready for events
  roomReadyForReadings = true;
  evidenceActive = false;
  roomEnterTime = Date.now();
  
  // Clear any existing timers
  if (roomTimerInterval) clearInterval(roomTimerInterval);
  if (evidenceTimer) clearTimeout(evidenceTimer);
  
  // Trigger room entry for JSON script system
  // pass the actual currentRoom so we don't get "undefined"
  onPlayerEntersRoom(currentRoom);
}

    
    function startEvidenceTimer() {
      if (!currentScenario) return;
      
      // Calculate evidence delay based on aggressiveness (10s-60s)
      const baseDelay = 10000; // 10 seconds minimum
      const maxDelay = 60000; // 60 seconds maximum
      const aggressiveness = currentScenario.aggressiveness || 0.5;
      
      // More aggressive = faster evidence (inverted)
      const delay = baseDelay + ((1 - aggressiveness) * (maxDelay - baseDelay));
      
      evidenceTimer = setTimeout(() => {
        if (currentRoom === currentScenario.room && roomReadyForReadings) {
          evidenceActive = true;
          // Could trigger visual/audio evidence here in future
        }
      }, delay);
    }

    function startGhostActivity() {
      if (!currentScenario || !investigationActive) return;
      
      // Only start activity for ghosts with EMF evidence
      if (!currentScenario.has_emf) return;
      
      ghostActivityActive = true;
      scheduleScenarioEvents();
    }

    function scheduleScenarioEvents() {
      if (!ghostActivityActive || !currentScenario) return;
      
      // Clear any existing timers
      if (ghostEventTimer) clearTimeout(ghostEventTimer);
      
      // Use JSON event timeline if available, otherwise fall back to old system
      if (currentScenario.events && currentScenario.events.length > 0) {
        scheduleJSONEvents();
      } else {
        scheduleClassBasedEvents(); // Fallback for embedded scenarios
      }
    }

    function scheduleJSONEvents() {
      const events = currentScenario.events;
      
      events.forEach(event => {
        const delayMs = event.time_seconds * 1000;
        
        setTimeout(() => {
          if (ghostActivityActive && investigationActive) {
            triggerJSONEvent(event);
          }
        }, delayMs);
      });
    }

    function scheduleClassBasedEvents() {
      // Fallback to old random system for embedded scenarios
      const classLevel = currentScenario.class_level || 2;
      let minMinutes, maxMinutes;
      
      switch(classLevel) {
        case 1: minMinutes = 8; maxMinutes = 15; break;
        case 2: minMinutes = 5; maxMinutes = 12; break;
        case 3: minMinutes = 3; maxMinutes = 8; break;
        case 4: minMinutes = 2; maxMinutes = 6; break;
        case 5: minMinutes = 1; maxMinutes = 4; break;
        default: minMinutes = 5; maxMinutes = 12; break;
      }
      
      const randomMinutes = minMinutes + Math.random() * (maxMinutes - minMinutes);
      const delayMs = randomMinutes * 60 * 1000;
      
      ghostEventTimer = setTimeout(() => {
        triggerGhostEvent();
        scheduleClassBasedEvents(); // Schedule next random event
      }, delayMs);
    }

    function triggerJSONEvent(event) {
      if (!currentScenario || !devicePowered || !roomReadyForReadings) return;
      if (currentRoom !== currentScenario.room) return;
      if (!currentScenario.has_emf) return;
      
      // Execute the specific event from JSON
      switch(event.type) {
        case 'emf_spike':
          forceEMFSpike(event.intensity, event.duration_ms);
          console.log(`EMF Event: ${event.description} (${event.intensity} EMF for ${event.duration_ms}ms)`);
          break;
        // Future: Add other event types like 'spirit_box_response', 'camera_interference', etc.
      }
    }

    function triggerGhostEvent() {
      if (!currentScenario || !devicePowered || !roomReadyForReadings) return;
      
      // Only trigger if player is in ghost room
      if (currentRoom !== currentScenario.room) return;
      
      // Only trigger for ghosts with EMF evidence
      if (!currentScenario.has_emf) return;
      
      // Create EMF spike event
      const spikeIntensity = Math.random() * 0.8 + 0.2; // 0.2 to 1.0
      const targetEMF = 5.0 + (spikeIntensity * 1.0); // 5.0 to 6.0 EMF spike
      
      // Force EMF spike for event
      forceEMFSpike(targetEMF, 2000 + Math.random() * 3000); // 2-5 second spike
    }

    function forceEMFSpike(targetValue, durationMs) {
      const originalEMF = currentEMF;
      
      // Rapidly increase to spike value
      currentEMF = targetValue;
      updateEMFDisplay(currentEMF);
      
      // Hold spike for duration, then return to normal
      setTimeout(() => {
        currentEMF = originalEMF;
        updateEMFDisplay(currentEMF);
      }, durationMs);
    }

    function stopGhostActivity() {
      ghostActivityActive = false;
      if (ghostEventTimer) {
        clearTimeout(ghostEventTimer);
        ghostEventTimer = null;
      }
    }
    
    // ===== INVESTIGATION =====
    async function startInvestigation() {
      const input = document.getElementById('gameCodeInput');
      const code = input.value;
      const errorElement = document.getElementById('codeError');
      
      if (code.length !== 3) {
        errorElement.style.display = 'block';
        errorElement.textContent = '‚ùå Error: Invalid Code Format';
        return;
      }
      
      if (availableRooms.length === 0) {
        errorElement.style.display = 'block';
        errorElement.textContent = '‚ùå Error: No Rooms Selected';
        return;
      }

      // Show loading message
      errorElement.style.display = 'block';
      errorElement.style.color = '#90EE90';
      errorElement.textContent = 'üì° Loading scenario data...';

      // Load new ghost data format only (no legacy loading)
      currentGhostData = await loadGhostDataJSON(code);
      
      if (!currentGhostData) {
        // Show error for unknown codes
        errorElement.style.color = '#ff6666';
        errorElement.textContent = '‚ùå Error: Wrong Case Code';
        return;
      }

      // Get ghost room from ghost data
      let ghostRoom;
      if (currentGhostData && currentGhostData.ghost_info) {
        // Convert dining_room -> Dining Room for room matching
        const rawRoom = currentGhostData.ghost_info.location;
        ghostRoom = rawRoom.split('_').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        
        // Handle common room name mappings
        if (ghostRoom === 'Dining Room') ghostRoom = 'Dinning Room'; // Match typo in room list
      }
      
      // Check if ghost room is available in selected rooms
      if (!ghostRoom || !availableRooms.includes(ghostRoom)) {
        errorElement.style.color = '#ff6666';
        errorElement.textContent = '‚ùå Error: Wrong Case Code';
        return;
      }

      // Initialize ghost position
      currentGhostRoom = ghostRoom;

      // Hide error and proceed
      errorElement.style.display = 'none';
      
      gameCode = code;
      investigationActive = true;
      startTime = Date.now();
      
      // Start room timer for initial room
      startRoomTimer();
      
      // Start NEW timeline system instead of old ghost activity
      startTimelineSystem();
      
      showScreen('toolScreen');
      createRoomNavigation();
      startTimer();
      updateDebug();
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!investigationActive || !startTime) return;
        const elapsed = Date.now() - startTime;
        const s = Math.floor(elapsed / 1000);
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600)/60);
        const sec = s % 60;
        const timeString = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
        
        // Update both timer displays
        document.getElementById('timerDisplay').textContent = timeString;
        document.getElementById('overlayTimer').textContent = timeString;
      }, 1000);
      
      // Show overlay timer
      document.getElementById('timerOverlay').classList.add('active');
    }

    function openTool(name) {
      if (name === 'emf') {
        showScreen('emfScreen');
        createRoomNavigation();
      } else if (name === 'spiritcam') {
        showScreen('spiritcamScreen');
        createRoomNavigation('roomNavigationCam');
        initializeCamera();
      }
    }

    // ===== SPIRIT CAM FUNCTIONS =====
    async function initializeCamera() {
      const statusElement = document.getElementById('camStatus');
      const videoElement = document.getElementById('cameraFeed');
      
      try {
        statusElement.textContent = 'Requesting camera access...';
        
        // Request camera access
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'environment', // Use back camera if available
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        
        videoElement.srcObject = cameraStream;
        statusElement.textContent = 'Camera active - Scanning for paranormal activity...';
        
        // Start ghost orbs detection in ghost room
        const ghostRoom = currentGhostData?.ghost_info?.location;
        const playerInGhostRoom = (currentRoom.toLowerCase().replace(/\s+/g, '_') === ghostRoom);
        
        if (playerInGhostRoom) {
          startGhostOrbs();
        }
        
      } catch (error) {
        statusElement.textContent = 'Camera access denied - Using simulated feed';
        videoElement.style.background = 'linear-gradient(45deg, #1a1a1a, #2a2a2a)';
        
        // Still allow ghost orbs in ghost room even without camera
        const ghostRoom = currentGhostData?.ghost_info?.location;
        const playerInGhostRoom = (currentRoom.toLowerCase().replace(/\s+/g, '_') === ghostRoom);
        
        if (playerInGhostRoom) {
          startGhostOrbs();
        }
      }
    }
    
    function setCameraMode(mode) {
      cameraMode = mode;
      const overlay = document.getElementById('cameraOverlay');
      const allBtns = document.querySelectorAll('.cam-btn');
      
      // Remove active class from all buttons
      allBtns.forEach(btn => btn.classList.remove('active'));
      
      // Add active class to selected button
      document.getElementById(`btn${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
      
      // Clear existing overlay classes
      overlay.className = 'camera-overlay';
      
      // Apply mode-specific styling
      switch(mode) {
        case 'normal':
          // No overlay
          break;
        case 'nightvision':
          overlay.classList.add('overlay-nightvision');
          break;
        case 'spirit':
          overlay.classList.add('overlay-spirit');
          break;
        case 'uv':
          overlay.classList.add('overlay-uv');
          toggleFlashlight(true);
          break;
      }
      
      // Turn off flashlight for non-UV modes
      if (mode !== 'uv') {
        toggleFlashlight(false);
      }
      
      // Update orb visibility based on mode
      updateOrbsForMode(mode);
    }
    
    function toggleFlashlight(state) {
      if (!cameraStream) return;
      
      const track = cameraStream.getVideoTracks()[0];
      const capabilities = track.getCapabilities();
      
      if (capabilities.torch) {
        track.applyConstraints({
          advanced: [{ torch: state }]
        }).catch(e => {
          // Flashlight not available, continue without it
        });
      }
      
      flashlightOn = state;
    }

    // ===== GHOST ORBS SYSTEM =====
    function startGhostOrbs() {
      if (ghostOrbsActive) return;
      
      ghostOrbsActive = true;
      orbsVisibilityState = true; // Start visible
      
      // Create initial orbs
      createGhostOrbs();
      
      // Start visibility loop: visible 1min ‚Üí hidden 2min ‚Üí repeat
      orbsLoop = setTimeout(() => {
        orbsVisibilityLoop();
      }, orbVisibleDuration);
    }
    
    function stopGhostOrbs() {
      ghostOrbsActive = false;
      orbsVisibilityState = false;
      
      if (orbsLoop) {
        clearTimeout(orbsLoop);
        orbsLoop = null;
      }
      
      // Remove all existing orbs
      currentOrbs.forEach(orb => {
        if (orb.element && orb.element.parentNode) {
          orb.element.parentNode.removeChild(orb.element);
        }
      });
      currentOrbs = [];
    }
    
    function orbsVisibilityLoop() {
      if (!ghostOrbsActive) return;
      
      if (orbsVisibilityState) {
        // Currently visible ‚Üí hide for 2 minutes
        orbsVisibilityState = false;
        hideAllOrbs();
        orbsLoop = setTimeout(() => {
          orbsVisibilityLoop();
        }, orbHiddenDuration);
      } else {
        // Currently hidden ‚Üí show for 1 minute
        orbsVisibilityState = true;
        createGhostOrbs();
        orbsLoop = setTimeout(() => {
          orbsVisibilityLoop();
        }, orbVisibleDuration);
      }
    }
    
    function createGhostOrbs() {
      if (!orbsVisibilityState || cameraMode === 'uv') return;
      
      // Remove existing orbs first
      hideAllOrbs();
      
      // Create random number of orbs (1 to maxOrbs)
      const numOrbs = Math.floor(Math.random() * maxOrbs) + 1;
      
      for (let i = 0; i < numOrbs; i++) {
        setTimeout(() => {
          if (orbsVisibilityState && ghostOrbsActive) {
            createSingleOrb();
          }
        }, Math.random() * 2000); // Stagger creation over 2 seconds
      }
    }
    
    function createSingleOrb() {
      const viewport = document.querySelector('.camera-viewport');
      if (!viewport) return;
      
      const orb = document.createElement('div');
      orb.className = 'ghost-orb';
      
      // Random size (simulates distance)
      const size = Math.random() * 20 + 10; // 10px to 30px
      orb.style.width = size + 'px';
      orb.style.height = size + 'px';
      
      // Random opacity (simulates brightness/distance)
      let opacity = Math.random() * 0.6 + 0.2; // 0.2 to 0.8
      
      // Brighter in spirit mode
      if (cameraMode === 'spirit') {
        opacity *= 1.5;
        orb.classList.add('spirit-mode');
      }
      
      orb.style.opacity = Math.min(opacity, 1);
      
      // Random horizontal movement
      const randomX = (Math.random() - 0.5) * 100; // -50px to 50px
      orb.style.setProperty('--random-x', randomX + 'px');
      
      // Random starting position
      orb.style.left = Math.random() * (viewport.clientWidth - size) + 'px';
      orb.style.top = viewport.clientHeight + 'px';
      
      // Add to viewport
      viewport.appendChild(orb);
      
      // Track orb
      const orbData = {
        element: orb,
        startTime: Date.now()
      };
      currentOrbs.push(orbData);
      
      // Remove orb after animation (10 seconds)
      setTimeout(() => {
        if (orb.parentNode) {
          orb.parentNode.removeChild(orb);
        }
        // Remove from tracking array
        const index = currentOrbs.findIndex(o => o.element === orb);
        if (index > -1) {
          currentOrbs.splice(index, 1);
        }
      }, 10000);
    }
    
    function hideAllOrbs() {
      currentOrbs.forEach(orb => {
        if (orb.element && orb.element.parentNode) {
          orb.element.parentNode.removeChild(orb.element);
        }
      });
      currentOrbs = [];
    }
    
    function updateOrbsForMode(mode) {
      if (mode === 'uv') {
        // Hide orbs in UV mode
        hideAllOrbs();
      } else if (orbsVisibilityState && ghostOrbsActive) {
        // Recreate orbs for new mode (spirit mode makes them brighter)
        createGhostOrbs();
      }
    }

    function endInvestigation() {
      if (!confirm('End investigation?')) return;
      
      investigationActive = false;
      gameCode = '';
      roomReadyForReadings = false;
      evidenceActive = false;
      currentGhostRoom = null;
      
      // Clear ghost data system
      currentGhostData = null;
      ghostTimeline = [];
      timelinePosition = 0;
      gameStartTime = 0;
      ghostEventQueue = [];
      
      // Clear all timers
      if (roomTimerInterval) clearInterval(roomTimerInterval);
      if (evidenceTimer) clearTimeout(evidenceTimer);
      if (timelineCheckInterval) clearInterval(timelineCheckInterval);
      if (eventProcessingInterval) clearInterval(eventProcessingInterval);
      if (timerInterval) clearInterval(timerInterval);
      
      // Stop old ghost activity system
      stopGhostActivity();
      
      // Cleanup Spirit Cam
      cleanupSpiritCam();
      
      stopEMFReadings();
      
      // Hide overlay timer
      document.getElementById('timerOverlay').classList.remove('active');
      
      showScreen('homeScreen');
      updateDebug();
    }

    function backToTools() {
      if (devicePowered) togglePower();
      cleanupSpiritCam();
      showScreen('toolScreen');
    }
    
    function cleanupSpiritCam() {
      // Stop camera stream
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      
      // Stop ghost orbs
      stopGhostOrbs();
      
      // Turn off flashlight
      toggleFlashlight(false);
    }

    // ===== EMF - ENHANCED WITH BETTER CALIBRATION =====
    function updateEMFDisplay(val) {
      document.querySelector('.emf-value').textContent = val.toFixed(2);
      const needle = document.querySelector('.needle');
      if (needle) {
        // Improved dial calibration using configurable angles
        // Map 0‚Äì6 EMF value to emfAngleMin‚ÄìemfAngleMax
        const fraction = Math.max(0, Math.min(1, val / 6)); // Clamp 0-1
        const angle = emfAngleMin + (emfAngleMax - emfAngleMin) * fraction;
        
        needle.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
      }
      
      // Handle beeping and spike detection
      handleEMFEffects(val);
    }

    function handleEMFEffects(val) {
      const spikeIndicator = document.getElementById('spikeIndicator');
      const spikeThreshold = 0.5; // How much change needed to trigger spike
      
      // Detect spikes
      const change = Math.abs(val - lastEMFValue);
      if (change > spikeThreshold && val > 2.0) {
        triggerSpike();
      }
      
      // Handle sustained high readings
      if (val >= 4.0) {
        if (!spikeIndicator.classList.contains('sustained')) {
          spikeIndicator.classList.remove('flash');
          spikeIndicator.classList.add('sustained');
        }
        handleBeeping(val);
      } else {
        spikeIndicator.classList.remove('sustained');
        stopBeeping();
      }
      
      lastEMFValue = val;
    }

    function triggerSpike() {
      const spikeIndicator = document.getElementById('spikeIndicator');
      spikeIndicator.classList.remove('sustained');
      spikeIndicator.classList.add('flash');
      
      // Remove flash class after animation
      setTimeout(() => {
        spikeIndicator.classList.remove('flash');
      }, 300);
    }

    function handleBeeping(emfValue) {
      if (!devicePowered) return;
      
      // Initialize audio context on first use
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Audio not supported');
          return;
        }
      }
      
      // Calculate beep interval based on EMF value (4.0 = 1000ms, 5.5+ = 100ms)
      const minInterval = 100; // Fastest beep (almost continuous)
      const maxInterval = 1000; // Slowest beep at EMF 4.0
      const emfRange = Math.max(0, Math.min(1.5, emfValue - 4.0)); // 0 to 1.5 range
      const intervalRange = maxInterval - minInterval;
      const currentInterval = maxInterval - (emfRange / 1.5) * intervalRange;
      
      // Clear existing beep interval
      if (beepInterval) {
        clearInterval(beepInterval);
      }
      
      // Start new beep interval
      beepInterval = setInterval(() => {
        playBeep();
      }, currentInterval);
      
      // Play immediate beep
      playBeep();
    }

    function playBeep() {
      if (!audioContext || audioContext.state === 'suspended') return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800 Hz beep
      oscillator.type = 'square';
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }

    function stopBeeping() {
      if (beepInterval) {
        clearInterval(beepInterval);
        beepInterval = null;
      }
    }

    function generateEMFReading() {
      if (!devicePowered) return;
      
      // Simple baseline fluctuation between 0.1 and 0.6
      let target = 0.1 + (Math.random() * 0.5); // 0.1 to 0.6
      
      // Smooth transition
      currentEMF += (target - currentEMF) * 0.1;
      currentEMF = Math.max(0, Math.min(6, currentEMF));
      updateEMFDisplay(currentEMF);
    }

    function startEMFReadings() {
      if (emfAnimationInterval) clearInterval(emfAnimationInterval);
      emfAnimationInterval = setInterval(generateEMFReading, 300);
    }

    function stopEMFReadings() {
      if (emfAnimationInterval) clearInterval(emfAnimationInterval);
      emfAnimationInterval = null;
      currentEMF = 0.0;
      lastEMFValue = 0.0;
      updateEMFDisplay(currentEMF);
      stopBeeping();
      
      // Reset spike indicator
      const spikeIndicator = document.getElementById('spikeIndicator');
      if (spikeIndicator) {
        spikeIndicator.classList.remove('flash', 'sustained');
      }
      
      document.getElementById('anomalyLed').classList.remove('on');
    }

    function togglePower() {
      if (!investigationActive) {
        alert('Start an investigation first');
        return;
      }
      
      devicePowered = !devicePowered;
      const powerLed = document.getElementById('powerLed');
      const calibLed = document.getElementById('calibLed');
      
      if (devicePowered) {
        powerLed.classList.add('on');
        calibLed.classList.add('on'); // Already green, just ensure it's visible
        startEMFReadings();
      } else {
        powerLed.classList.remove('on');
        calibLed.classList.remove('on'); // Keep it green but dimmer
        stopEMFReadings();
      }
    }

    // ===== EMF CALIBRATION FUNCTIONS (For Testing) =====
    function updateDialCalibration() {
      emfAngleMin = parseInt(document.getElementById('angleMin').value);
      emfAngleMax = parseInt(document.getElementById('angleMax').value);
      
      // Update current reading to reflect new calibration
      if (devicePowered) {
        updateEMFDisplay(currentEMF);
      }
    }

    function testEMFReading() {
      if (!devicePowered) return;
      const testValue = parseFloat(document.getElementById('testEMF').value);
      currentEMF = testValue;
      updateEMFDisplay(currentEMF);
    }

    // Enable calibration mode (uncomment to enable testing controls)
    function enableCalibrationMode() {
      document.getElementById('emfCalibration').style.display = 'block';
    }

    // ===== INIT =====
    document.addEventListener('DOMContentLoaded', function(){
      // Code input - numeric only
      document.getElementById('gameCodeInput').addEventListener('keypress', function(e){
        if (e.key === 'Enter') startInvestigation();
        if (!/[0-9]/.test(e.key) && e.key !== 'Backspace' && e.key !== 'Delete' && e.key !== 'Enter') {
          e.preventDefault();
        }
      });
      
      // Initialize audio context on first user interaction
      document.addEventListener('click', function initAudio() {
        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') {
              audioContext.resume();
            }
          } catch (e) {
            console.log('Audio not supported');
          }
        }
        // Remove listener after first click
        document.removeEventListener('click', initAudio);
      });
      
      updateDebug();
      
      // Uncomment this line to enable EMF calibration controls for testing:
      // enableCalibrationMode();
    });
  </script>
</body>
</html>
